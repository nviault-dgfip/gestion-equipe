from flask import Flask, render_template, request, send_file, redirect, url_for, flash
import pandas as pd
import json
import os
import numpy as np
from datetime import datetime, timedelta, date
from io import BytesIO
import jours_feries_france

app = Flask(__name__)
app.secret_key = 'secret_key_secure_app_gestion'

# --- CONFIGURATION ---
JSON_FILE = "equipe.json"
UPLOAD_FOLDER = '/tmp'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# --- FONCTIONS UTILITAIRES ---

def load_team():
    """Charge l'équipe et migre automatiquement l'ancien format vers le format liste de BCs"""
    if not os.path.exists(JSON_FILE): return []
    with open(JSON_FILE, 'r') as f:
        try:
            data = json.load(f)
        except:
            return []
   
    # MIGRATION AUTOMATIQUE (Ancien format plat -> Nouveau format liste)
    cleaned_data = []
    for m in data:
        # Si c'est un prestataire et qu'il n'a pas la liste 'bons_commande'
        if m.get('type') == 'prestataire' and 'bons_commande' not in m:
            bc = {
                "marche_id": m.get('marche_id', ''),
                "bc_id": m.get('bc_id', ''),
                "jours_commandes": float(m.get('jours_commandes', 0) or 0),
                "date_debut": m.get('date_debut', ''),
                "tjm_ht": float(m.get('tjm_ht', 0) or 0)
            }
            m['bons_commande'] = [bc]
            # On nettoie les anciens champs pour ne pas garder de doublons
            for k in ['marche_id', 'bc_id', 'jours_commandes', 'date_debut', 'tjm_ht']:
                m.pop(k, None)
        cleaned_data.append(m)
    return cleaned_data

def save_team_json(data):
    with open(JSON_FILE, 'w') as f:
        json.dump(data, f, indent=4)

def is_holiday_or_weekend(target_date):
    """Vérifie Week-ends et Jours fériés France"""
    # 1. Samedi (5) ou Dimanche (6)
    if target_date.weekday() >= 5: return True
   
    # 2. Fériés
    res = jours_feries_france.JoursFeries.for_year(target_date.year)
    if target_date in res.values(): return True
   
    return False

def calculate_end_date(start_date_str, days_to_consume, presence_pct):
    """
    Estime la date de fin en projetant les jours ouvrés dans le futur.
    """
    if days_to_consume <= 0: return "Terminé"
   
    daily_burn = presence_pct / 100.0
    if daily_burn == 0: return "Jamais"
   
    try:
        current_date = datetime.strptime(str(start_date_str), "%Y-%m-%d").date()
    except:
        # Si pas de date début, on part d'aujourd'hui
        current_date = date.today()

    remaining_days = days_to_consume
   
    # Sécurité boucle infinie (max 5 ans)
    max_iter = 365 * 5
    i = 0
    while remaining_days > 0 and i < max_iter:
        current_date += timedelta(days=1)
        i += 1
        # On ne décrémente le compteur que si c'est un jour travaillé
        if not is_holiday_or_weekend(current_date):
            remaining_days -= daily_burn
           
    return current_date.strftime("%d/%m/%Y")

def process_excel(filepath):
    """Lit le fichier Excel et compte les X par personne"""
    try:
        xls = pd.read_excel(filepath, sheet_name=None, engine='openpyxl')
        consumption = {}
        ignored = ["Paramètres_Equipe", "Parametres", "Config"]
       
        for sheet, df in xls.items():
            if any(x in sheet for x in ignored): continue
           
            # Nettoyage des noms de colonnes
            df.columns = df.columns.astype(str).str.strip()
            if "Date" not in df.columns: continue
           
            # Gestion des cellules fusionnées pour la date
            df['Date'] = df['Date'].ffill()
           
            # Identification des membres (colonnes autres que Date/Période)
            cols = [c for c in df.columns if c not in ["Date", "Période"] and "Unnamed" not in c]
           
            for member in cols:
                if member not in consumption: consumption[member] = 0.0
               
                # On ne garde que les valeurs non nulles
                sub = df[member].dropna().astype(str).str.upper().str.strip()
                count_x = (sub == 'X').sum()
                consumption[member] += (count_x * 0.5)
                       
        return consumption
    except Exception as e:
        print(f"Erreur process: {e}")
        return {}

def generate_report_dataframe(conso_map, team):
    """Génère le rapport en gérant la consommation en cascade sur les BCs"""
    report_data = []
    prestataires = [p for p in team if p.get('type') == 'prestataire']
   
    for p in prestataires:
        nom_complet = f"{p['prenom']} {p['nom']}"
       
        # 1. Trouver la consommation totale de la personne dans l'Excel
        total_consumed = 0
        nom_complet_search = nom_complet.lower()
       
        # Logique de matching de nom
        for excel_name, val in conso_map.items():
            # "Martin Sophie" in "Sophie Martin" (vice versa) ou matching partiel
            if excel_name.lower() in nom_complet_search or p['nom'].lower() in excel_name.lower():
                total_consumed = val
                break
       
        pct_presence = float(p.get('presence_pct', 100))
       
        # 2. Récupérer et Trier les BCs par date
        bcs = p.get('bons_commande', [])
        # Tri sur la date de début (les vides vont à la fin)
        bcs.sort(key=lambda x: x.get('date_debut') or '9999-99-99')
       
        # 3. Logique du "Seau" (Bucket)
        consumed_buffer = total_consumed
       
        for bc in bcs:
            days_ordered = float(bc.get('jours_commandes', 0))
            start_date = bc.get('date_debut', date.today().strftime("%Y-%m-%d"))
            tjm = float(bc.get('tjm_ht', 0))
           
            # Détermination de l'état du BC
            if consumed_buffer >= days_ordered:
                # Ce BC est entièrement consommé / Terminé
                conso_sur_ce_bc = days_ordered
                etat = "Terminé"
                consumed_buffer -= days_ordered
                fin_estimee = "Clôturé"
               
            elif consumed_buffer > 0:
                # Ce BC est en cours (entamé mais pas fini)
                conso_sur_ce_bc = consumed_buffer
                etat = "En cours"
                consumed_buffer = 0 # Le buffer est vide, les suivants seront futurs
               
                # Calcul de la fin estimée
                reste_a_faire = days_ordered - conso_sur_ce_bc
                # On estime la fin en partant de la date théorique de début + consommation totale
                # (Simplification : on projette le reste à partir d'aujourd'hui ou du début)
                fin_estimee = calculate_end_date(start_date, days_ordered, pct_presence)
               
            else:
                # Ce BC n'est pas encore entamé
                conso_sur_ce_bc = 0
                etat = "Futur"
                # La date de fin estimée est purement théorique (Durée totale à partir du début)
                fin_estimee = calculate_end_date(start_date, days_ordered, pct_presence)
           
            report_data.append({
                "Nom": nom_complet,
                "État": etat,
                "Marché": bc.get('marche_id', '-'),
                "BC": bc.get('bc_id', '-'),
                "Début": start_date,
                "Commandé": days_ordered,
                "Conso": conso_sur_ce_bc,
                "Reste": days_ordered - conso_sur_ce_bc,
                "Fin Estimée": fin_estimee,
                "Montant HT": conso_sur_ce_bc * tjm,
                "TJM": tjm # Gardé pour info export
            })
           
    df = pd.DataFrame(report_data)
    return df

# --- ROUTES ---

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        if 'file' not in request.files: return redirect(request.url)
        file = request.files['file']
        if file.filename == '': return redirect(request.url)
       
        if file:
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], 'planning_temp.xlsx')
            file.save(filepath)
           
            # Calculs
            conso_map = process_excel(filepath)
            team = load_team()
            df = generate_report_dataframe(conso_map, team)
           
            # Formatage Web
            df_web = df.copy()
            if not df_web.empty:
                df_web["Montant HT"] = df_web["Montant HT"].apply(lambda x: f"{x:.2f} €")
                # Colonnes à afficher
                cols = ["Nom", "État", "Marché", "BC", "Début", "Commandé", "Conso", "Reste", "Fin Estimée", "Montant HT"]
                # On filtre si les colonnes existent
                existing_cols = [c for c in cols if c in df_web.columns]
                df_web = df_web[existing_cols]

            table_html = df_web.to_html(classes="table table-striped table-bordered align-middle table-hover", index=False)
            return render_template('dashboard.html', table=table_html)

    return render_template('index.html')

@app.route('/export_excel')
def export_excel():
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], 'planning_temp.xlsx')
    if not os.path.exists(filepath): return "Aucun fichier source. Importez d'abord.", 400
   
    conso_map = process_excel(filepath)
    team = load_team()
    df = generate_report_dataframe(conso_map, team)
   
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Suivi Financier')
    output.seek(0)
   
    return send_file(output, download_name=f"Suivi_{datetime.now().strftime('%Y-%m-%d')}.xlsx", as_attachment=True, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

# --- GESTION EQUIPE ---

@app.route('/equipe')
def equipe_index():
    team = load_team()
    return render_template('team.html', team=team)

@app.route('/equipe/save', methods=['POST'])
def equipe_save():
    team = load_team()
    data = request.form
    member_id = data.get('id')
   
    # Objet de base
    new_member = {
        "type": data.get('type'),
        "nom": data.get('nom'),
        "prenom": data.get('prenom'),
        "presence_pct": int(data.get('presence_pct') or 100)
    }
   
    # Gestion des BCs multiples (Prestataire uniquement)
    if data.get('type') == 'prestataire':
        # Flask permet de récupérer les listes des champs nommés "name[]"
        marches = data.getlist('bc_marche[]')
        ids = data.getlist('bc_id[]')
        jours = data.getlist('bc_jours[]')
        debuts = data.getlist('bc_debut[]')
        tjms = data.getlist('bc_tjm[]')
       
        bcs = []
        # On itère sur les index
        for i in range(len(marches)):
            # On ignore les lignes complètement vides
            if marches[i] or ids[i]:
                bcs.append({
                    "marche_id": marches[i],
                    "bc_id": ids[i],
                    "jours_commandes": float(jours[i] or 0),
                    "date_debut": debuts[i],
                    "tjm_ht": float(tjms[i] or 0)
                })
        new_member['bons_commande'] = bcs

    # Sauvegarde (Ajout ou Edit)
    if member_id:
        for i, m in enumerate(team):
            if str(m.get('id')) == str(member_id):
                new_member['id'] = m['id']
                team[i] = new_member
                break
    else:
        new_id = 1
        if team: new_id = max(m.get('id', 0) for m in team) + 1
        new_member['id'] = new_id
        team.append(new_member)

    save_team_json(team)
    flash(f"Membre {new_member['prenom']} {new_member['nom']} mis à jour !", "success")
    return redirect(url_for('equipe_index'))

@app.route('/equipe/delete/<int:id>', methods=['POST'])
def equipe_delete(id):
    team = load_team()
    new_team = [m for m in team if m.get('id') != id]
    save_team_json(new_team)
    flash("Membre supprimé.", "warning")
    return redirect(url_for('equipe_index'))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)
